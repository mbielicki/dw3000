/*********************************************************************
*                   (c) SEGGER Microcontroller GmbH                  *
*                        The Embedded Experts                        *
**********************************************************************
*                                                                    *
*       (c) 2003 - 2024     SEGGER Microcontroller GmbH              *
*                                                                    *
*       www.segger.com     Support: www.segger.com/ticket            *
*                                                                    *
**********************************************************************
*                                                                    *
*       emUSB-Device * USB Device stack for embedded applications    *
*                                                                    *
*       Please note: Knowledge of this file may under no             *
*       circumstances be used to write a similar product.            *
*       Thank you for your fairness !                                *
*                                                                    *
**********************************************************************
*                                                                    *
*       emUSB-Device version: V3.64.2                                *
*                                                                    *
**********************************************************************
-------------------------- END-OF-HEADER -----------------------------

Purpose : emUSB-Web application. Provides access to a web server via USB.

Additional information:
  Preparations:
    The emWeb Webserver is necessary.
    The PC tool "emUSB-Web" is necessary. It can be downloaded here:
    https://www.segger.com/products/connectivity/emusb-device/add-ons/emusb-web/

    Start the tool and connect the device to your PC.

  Expected behavior:
    [PC] Upon connection the website generated by the target is seen in the default browser.

    [Target] The debug terminal displays which website resources are being accessed by the browser.

  Sample output:
    1:283 MainTask - WebS: Get /
    1:285 MainTask - Request complete

    1:307 MainTask - WebS: Get /Styles.css
    1:309 MainTask - Request complete

    1:409 MainTask - WebS: Get /Logo.gif
    1:411 MainTask - Request complete
*/

/*********************************************************************
*
*       #include section
*
**********************************************************************
*/
#include <stdio.h>
#include <stdlib.h>
#include "USB_Bulk.h"
#include "IP_Webserver.h"
#include "SEGGER_MEM.h"
#include "BSP.h"

/*********************************************************************
*
*       Defines, configurable
*
**********************************************************************
*/
#define USB_WRITE_TIMEOUT 100
#define USB_READ_TIMEOUT 100

/*********************************************************************
*
*       Defines, fixed
*
**********************************************************************
*/
//
// These IDs must match the IDs used in the PC tool so that both sides can recognize each other.
//
#define EMUSB_WEB_CLASS_ID     0xFF // Vendor specific
#define EMUSB_WEB_SUBCLASS_ID  0x57 // ASCII 'W'
#define EMUSB_WEB_PROTOCOL_ID  0x45 // ASCII 'E'

/*********************************************************************
*
*       Forward declarations
*
**********************************************************************
*/
#ifdef __cplusplus
extern "C" {     /* Make sure we have C-declarations in C++ programs */
#endif
void MainTask(void);
#ifdef __cplusplus
}
#endif

/*********************************************************************
*
*       Information that are used during enumeration
*/
static const USB_DEVICE_INFO _DeviceInfo = {
  0x8765,         // VendorId
  0x6000,         // ProductId
  "Vendor",       // VendorName
  "USB Webserver",// ProductName
  "13245678"      // SerialNumber
};

//
// Header sent by the PC tool before data payloads.
//
typedef struct {
  U32 NumBytesDataDown; // Number of data bytes following this header.
  U16 Reserved1;        // Reserved for future use.
  U16 Reserved2;        // Reserved for future use.
} DOWN_HEADER;

//
// Header sent by the embedded side to the PC tool before data payloads.
//
typedef struct {
  U32 NumBytesDataUp;   // Number of data bytes following this header.
  U16 RetVal;           // Request return code:
                        // 0 - More data will be sent by the webserver
                        // 1 - Reserved.
                        // 2 - Request completed, PC can start a new request
  U16 Reserved;         // Reserved for future use.
} UP_HEADER;

typedef struct {
  int MenuIndex;
} DYNC_CONTEXT;

/*********************************************************************
*
*       Static data
*
**********************************************************************
*/
static USB_BULK_HANDLE        _hInst;                             // Bulk instance handle.
static U32                    _NumBytesDown;                      // Size of the current payload being received from the PC tool.
static U32                    _MEM_ac[1024 * 3 / sizeof(U32)];    // Measured heap usage values:
                                                                  // 2296 bytes in debug
//
// SEGGER memory management context structure (used by emWeb).
//
static SEGGER_MEM_CONTEXT     _MEM_Context;
static SEGGER_MEM_SIMPLE_HEAP _MEM_Heap;

/*********************************************************************
*
*       Public code
*
**********************************************************************
*/

/*********************************************************************
*
*       _WEBS_Recv()
*
*  Function description
*    Web Server API wrapper for recv().
*/
static int _WEBS_Recv(unsigned char *buf, int len, void *pConnectionInfo) {
  DOWN_HEADER DownHeader;
  int r;

  (void)pConnectionInfo;
  //
  // Receive header from the PC if there is no ongoing payload (_NumBytesDown == 0).
  //
  r = 0;
  if (_NumBytesDown == 0u) {
    r = USBD_BULK_Receive(_hInst, &DownHeader, sizeof(DownHeader), 0);
    if (r == sizeof(DownHeader)) {
      _NumBytesDown = DownHeader.NumBytesDataDown;
    }
  }
  //
  // If we received a valid header receive the payload data.
  //
  if (r >= 0) {
    r = USBD_BULK_Receive(_hInst, buf, SEGGER_MIN((U32)len, _NumBytesDown), 0);
    if (r >= 0) {
      _NumBytesDown -= r;
    } else {
      //
      // USBD_BULK_Receive() returned with an error, reset the transfer by setting the current payload size to 0.
      //
      _NumBytesDown = 0;
    }
  }
  return r;
}

/*********************************************************************
*
*       _WEBS_Send()
*
*  Function description
*    Web Server API wrapper for send()
*/
static int _WEBS_Send(const U8 *pBuf, int Len, void* pConnectionInfo) {
  UP_HEADER UpHeader;
  int r;

  (void)pConnectionInfo;
  //
  // Send header to the PC.
  //
  UpHeader.RetVal = 0;
  UpHeader.Reserved = 0;
  UpHeader.NumBytesDataUp = (U32)Len;
  r = USBD_BULK_Write(_hInst, &UpHeader, sizeof(UpHeader), USB_WRITE_TIMEOUT);
  if (r == sizeof(UpHeader)) {
    //
    // Send data to the PC.
    //
    r = USBD_BULK_Write(_hInst, pBuf, Len, USB_WRITE_TIMEOUT);
  }
  return r;
}

/*********************************************************************
*
*       WebS transport layer
*
*  Description
*    Web server transport API for plain connections.
*/
static const WEBS_IP_API _Webs_IP_API = {
  _WEBS_Send,
  _WEBS_Recv
};

/*********************************************************************
*
*       _Alloc()
*
*  Function description
*    Wrapper for Alloc(). (emNet: IP_MEM_Alloc())
*/
static void * _Alloc(U32 NumBytesReq) {
  return SEGGER_MEM_Alloc(&_MEM_Context, NumBytesReq);
}

/*********************************************************************
*
*       _Free()
*
*  Function description
*    Wrapper for Alloc(). (emNet: IP_MEM_Alloc())
*/
static void _Free(void *p) {
  SEGGER_MEM_Free(&_MEM_Context, p);
}

/*********************************************************************
*
*       WEBS_SYS_API
*
*  Description
*   System related function table
*/
static const WEBS_SYS_API _Webs_SYS_API = {
  _Alloc,
  _Free
};

/*********************************************************************
*
*       _USBD_BULK_Init
*
*  Function description
*    Add generic USB BULK interface to USB stack
*/
static void _USBD_BULK_Init(void) {
  static U8             _abOutBuffer[USB_HS_BULK_MAX_PACKET_SIZE];
  USB_BULK_INIT_DATA_EX InitData;
  USB_ADD_EP_INFO       EPIn;
  USB_ADD_EP_INFO       EPOut;

  memset(&InitData, 0, sizeof(InitData));
  EPIn.Flags          = 0;                             // Flags not used.
  EPIn.InDir          = USB_DIR_IN;                    // IN direction (Device to Host)
  EPIn.Interval       = 0;                             // Interval not used for Bulk endpoints.
  EPIn.MaxPacketSize  = USB_HS_BULK_MAX_PACKET_SIZE;   // Maximum packet size (512 for Bulk in high-speed).
  EPIn.TransferType   = USB_TRANSFER_TYPE_BULK;        // Endpoint type - Bulk.
  InitData.EPIn  = USBD_AddEPEx(&EPIn, NULL, 0);

  EPOut.Flags         = 0;                             // Flags not used.
  EPOut.InDir         = USB_DIR_OUT;                   // OUT direction (Host to Device)
  EPOut.Interval      = 0;                             // Interval not used for Bulk endpoints.
  EPOut.MaxPacketSize = USB_HS_BULK_MAX_PACKET_SIZE;   // Maximum packet size (512 for Bulk in high-speed).
  EPOut.TransferType  = USB_TRANSFER_TYPE_BULK;        // Endpoint type - Bulk.
  InitData.EPOut = USBD_AddEPEx(&EPOut, _abOutBuffer, sizeof(_abOutBuffer));

  InitData.Flags = USB_BULK_FLAG_USE_CUSTOM_CLASS_IDS;
  InitData.InterfaceClass    = EMUSB_WEB_CLASS_ID;
  InitData.InterfaceSubClass = EMUSB_WEB_SUBCLASS_ID;
  InitData.InterfaceProtocol = EMUSB_WEB_PROTOCOL_ID;
  InitData.pInterfaceName = "SEGGER emUSB-Web - http";

  _hInst = USBD_BULK_Add_Ex(&InitData);
  USBD_BULK_SetMSDescInfo(_hInst);
}

/*********************************************************************
*
*       _cbGetFileInfo
*/
static void _cbGetFileInfo(const char* sFilename, IP_WEBS_FILE_INFO* pFileInfo) {
  int r;
  //
  // .cgi files are virtual, everything else is not
  //
  r = IP_WEBS_CompareFilenameExt(sFilename, ".cgi");  // Returns == 0 on match
  pFileInfo->IsVirtual = (r == 0) ? 1 : 0;
  //
  // .htm files contain dynamic content, everything else is not
  //
  r = IP_WEBS_CompareFilenameExt(sFilename, ".htm");  // Returns == 0 on match
  pFileInfo->AllowDynContent = (r == 0) ? 1 : 0;
  //
  // Static files should have a long expiration date
  //
  if (IP_WEBS_CompareFilenameExt(sFilename, ".css") == 0 ||
      IP_WEBS_CompareFilenameExt(sFilename, ".png") == 0 ||
      IP_WEBS_CompareFilenameExt(sFilename, ".ico") == 0 ||
      IP_WEBS_CompareFilenameExt(sFilename, ".svg") == 0) {
    pFileInfo->DateExp = (1uL << 16) | (1uL << 21) | (77uL << 25);  // Default expiration is Jan.1 2057, 00:00:00.
  }
}

/*********************************************************************
*
*       _WebserverTask
*/
static void _WebserverTask(void) {
  WEBS_CONTEXT  ChildContext;
  DYNC_CONTEXT  DyncContext;
  UP_HEADER     UpHeader;
  int           r;

  //
  // Initialize the context of the child task.
  //
  IP_WEBS_Init(&ChildContext, &_Webs_IP_API, &_Webs_SYS_API, &IP_FS_ReadOnly, &WebsSample_Application);
  //
  // Specify callback to be called when a request for a file is coming in.
  // Callback may set "allow dynamic content" in file info.
  //
  IP_WEBS_SetFileInfoCallback(&_cbGetFileInfo);
  do {
    //
    // Wait for USB to enumerate.
    //
    while ((USBD_GetState() & (USB_STAT_CONFIGURED | USB_STAT_SUSPENDED)) != USB_STAT_CONFIGURED) {
      _NumBytesDown = 0;
      BSP_ToggleLED(0);
      USB_OS_Delay(50);
    }
    BSP_ClrLED(0); // Make sure LED state does not interfere with the samples
    do {
      //
      // Handle new request from web browser on host side, we got forwarded via USB.
      //
      memset(&DyncContext, 0, sizeof(DyncContext));
      r = IP_WEBS_ProcessLastEx(&ChildContext, &DyncContext, NULL);   // Will sleep implicitly inside pfReceive() if there is no new request available from the host side
      if (r != 0) {
        USBD_Logf_Application("IP_WEBS_ProcessLastEx returns %d\n", r);
      } else {
        //
        // Send header to the PC.
        //
        UpHeader.RetVal = 2;
        UpHeader.Reserved = 0;
        UpHeader.NumBytesDataUp = 0;
        (void)USBD_BULK_Write(_hInst, &UpHeader, sizeof(UpHeader), USB_WRITE_TIMEOUT);
      }
    } while ((USBD_GetState() & (USB_STAT_CONFIGURED | USB_STAT_SUSPENDED)) == USB_STAT_CONFIGURED);
  } while (1);
}

/*********************************************************************
*
*       MainTask
*/
void MainTask(void) {
  //
  // Initialize SEGGER Heap
  //
  SEGGER_MEM_SIMPLE_HEAP_Init(&_MEM_Context, &_MEM_Heap, &_MEM_ac[0], sizeof(_MEM_ac), 8);
  //
  // Initialize USB
  //
  USBD_Init();
  _USBD_BULK_Init();
  USBD_SetDeviceInfo(&_DeviceInfo);
  USBD_Start();
  //
  // Handle Webserver communication
  //
  IP_WEBS_X_SampleConfig();
  _WebserverTask();
}
